<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>iPod Transcode & Folder Sync</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 24px;
        background: #f5f5f7;
        color: #1d1d1f;
      }

      h1 {
        margin-bottom: 24px;
        font-size: 1.5rem;
      }

      .folder-pickers {
        display: flex;
        gap: 16px;
        margin-bottom: 24px;
      }

      .folder-picker {
        flex: 1;
        padding: 16px;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition:
          outline 0.15s,
          background 0.15s;
      }

      .folder-picker.drag-over {
        outline: 2px dashed #0071e3;
        background: #f0f4ff;
      }

      .folder-picker button {
        width: 100%;
        padding: 10px 16px;
        font-size: 0.9rem;
        border: none;
        border-radius: 8px;
        background: #0071e3;
        color: #fff;
        cursor: pointer;
      }

      .folder-picker button:hover {
        background: #0077ed;
      }

      .folder-picker .folder-name {
        margin-top: 8px;
        font-size: 0.85rem;
        color: #6e6e73;
        min-height: 1.2em;
      }

      .actions {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .actions button {
        padding: 10px 20px;
        font-size: 0.9rem;
        border: none;
        border-radius: 8px;
        background: #34c759;
        color: #fff;
        cursor: pointer;
      }

      .actions button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .actions button:not(:disabled):hover {
        background: #30b350;
      }

      .select-controls {
        display: flex;
        gap: 8px;
      }

      .select-controls button {
        padding: 6px 12px;
        font-size: 0.8rem;
        background: #e5e5ea;
        color: #1d1d1f;
      }

      .select-controls button:hover {
        background: #d1d1d6;
      }

      #progress-area {
        margin-bottom: 16px;
        padding: 12px 16px;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        display: none;
      }

      #progress-area .bar-container {
        width: 100%;
        height: 8px;
        background: #e5e5ea;
        border-radius: 4px;
        margin-top: 8px;
        overflow: hidden;
      }

      #progress-area .bar-fill {
        height: 100%;
        width: 0%;
        background: #0071e3;
        border-radius: 4px;
        transition: width 0.2s;
      }

      #progress-text {
        font-size: 0.85rem;
        color: #6e6e73;
      }

      .album-list {
        list-style: none;
      }

      .album-list li {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 16px;
        background: #fff;
        margin-bottom: 2px;
        font-size: 0.9rem;
      }

      .album-list li:first-child {
        border-radius: 12px 12px 0 0;
      }
      .album-list li:last-child {
        border-radius: 0 0 12px 12px;
      }
      .album-list li:only-child {
        border-radius: 12px;
      }

      .album-list li.present {
        color: #6e6e73;
      }

      .album-name {
        flex: 1;
      }

      .album-meta {
        font-size: 0.8rem;
        color: #86868b;
        white-space: nowrap;
      }

      .badge {
        font-size: 0.75rem;
        padding: 2px 8px;
        border-radius: 4px;
        font-weight: 600;
      }

      .badge.missing {
        background: #fff3cd;
        color: #856404;
      }
      .badge.incomplete {
        background: #ffe0cc;
        color: #984c0c;
      }
      .badge.present {
        background: #d4edda;
        color: #155724;
      }
      .badge.synced {
        background: #d4edda;
        color: #155724;
      }

      #about summary {
        cursor: pointer;
      }
      #about p {
        font-size: 0.85rem;
        font-weight: normal;
        color: #6e6e73;
        line-height: 1.5;
        margin-top: 8px;
      }

      .empty-state {
        text-align: center;
        color: #86868b;
        padding: 48px 16px;
      }

      #error-notice {
        display: none;
        padding: 10px 16px;
        margin-bottom: 16px;
        background: #f8d7da;
        color: #721c24;
        border-radius: 12px;
        font-size: 0.9rem;
      }

      #sync-log {
        margin-top: 16px;
        display: none;
      }

      #sync-log summary {
        cursor: pointer;
        font-size: 0.85rem;
        color: #6e6e73;
        padding: 8px 0;
      }

      #sync-log pre {
        max-height: 400px;
        overflow: auto;
        padding: 12px;
        background: #1d1d1f;
        color: #e0e0e0;
        border-radius: 8px;
        font-size: 0.75rem;
        line-height: 1.4;
        white-space: pre-wrap;
        word-break: break-all;
      }
    </style>
  </head>
  <body>
    <h1>
      <details id="about">
        <summary>iPod Transcode &amp; Folder Sync</summary>
        <p>
          Compare a source music folder against a target (iPod) folder. Missing
          child folders (albums) can be selected and synced, with FLAC files
          transcoded to ALAC for bettery battery life on old iPods. Other
          formats are copied as-is. Everything runs in the browser, no server
          needed.
        </p>
      </details>
    </h1>

    <div class="folder-pickers">
      <div class="folder-picker">
        <button id="btn-source">Select Source Folder</button>
        <div class="folder-name" id="source-name"></div>
      </div>
      <div class="folder-picker">
        <button id="btn-target">Select Target (iPod) Folder</button>
        <div class="folder-name" id="target-name"></div>
      </div>
    </div>

    <div class="actions">
      <button id="btn-sync" disabled>Sync Selected</button>
      <div class="select-controls">
        <button id="btn-select-all">Select All Missing</button>
        <button id="btn-select-none">Select None</button>
      </div>
    </div>

    <div id="progress-area">
      <div id="progress-text"></div>
      <div class="bar-container">
        <div class="bar-fill" id="progress-bar"></div>
      </div>
    </div>

    <div id="error-notice"></div>

    <ul class="album-list" id="album-list"></ul>
    <div class="empty-state" id="empty-state">
      Select source and target folders to compare.
    </div>

    <details id="sync-log">
      <summary>Sync log</summary>
      <pre id="sync-log-content"></pre>
    </details>

    <script type="module">
      import { FFmpeg } from '@ffmpeg/ffmpeg';
      import { toBlobURL, fetchFile } from '@ffmpeg/util';

      const AUDIO_EXTS = new Set([
        '.flac',
        '.m4a',
        '.mp3',
        '.aac',
        '.aiff',
        '.wav',
        '.alac',
      ]);

      // State
      let sourceHandle = null;
      let targetHandle = null;
      let sourceAlbums = [];
      let targetAlbumCounts = new Map(); // normalizedName → track count
      let comparisonResults = []; // { name, normalizedName, files, status: 'missing'|'present' }

      // DOM
      const btnSource = document.getElementById('btn-source');
      const btnTarget = document.getElementById('btn-target');
      const btnSync = document.getElementById('btn-sync');
      const btnSelectAll = document.getElementById('btn-select-all');
      const btnSelectNone = document.getElementById('btn-select-none');
      const sourceName = document.getElementById('source-name');
      const targetName = document.getElementById('target-name');
      const albumListEl = document.getElementById('album-list');
      const emptyState = document.getElementById('empty-state');
      const progressArea = document.getElementById('progress-area');
      const progressText = document.getElementById('progress-text');
      const progressBar = document.getElementById('progress-bar');
      const errorNotice = document.getElementById('error-notice');
      const syncLog = document.getElementById('sync-log');
      const syncLogContent = document.getElementById('sync-log-content');

      function normalize(name) {
        return name.trim().toLowerCase();
      }

      function ext(filename) {
        const i = filename.lastIndexOf('.');
        return i >= 0 ? filename.slice(i).toLowerCase() : '';
      }

      async function scanFolder(dirHandle) {
        const albums = [];
        for await (const [name, handle] of dirHandle.entries()) {
          if (handle.kind !== 'directory') continue;
          const files = [];
          for await (const [fname, fhandle] of handle.entries()) {
            if (fhandle.kind === 'file' && AUDIO_EXTS.has(ext(fname))) {
              files.push(fhandle);
            }
          }
          if (files.length > 0) {
            albums.push({ name, normalizedName: normalize(name), files });
          }
        }
        albums.sort((a, b) => a.name.localeCompare(b.name));
        return albums;
      }

      async function pickFolder(label) {
        try {
          return await window.showDirectoryPicker({
            id: label,
            mode: 'readwrite',
          });
        } catch {
          return null;
        }
      }

      function compare() {
        comparisonResults = sourceAlbums.map((album) => {
          const targetCount = targetAlbumCounts.get(album.normalizedName);
          const sourceCount = album.files.length;
          let status;
          if (targetCount == null) {
            status = 'missing';
          } else if (targetCount < sourceCount) {
            status = 'incomplete';
          } else {
            status = 'present';
          }
          return { ...album, status, targetCount: targetCount ?? 0 };
        });
        render();
      }

      function render() {
        albumListEl.innerHTML = '';
        if (comparisonResults.length === 0) {
          emptyState.style.display = 'block';
          btnSync.disabled = true;
          return;
        }
        emptyState.style.display = 'none';

        for (const album of comparisonResults) {
          const li = document.createElement('li');
          if (album.status === 'present') li.classList.add('present');

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = album.status !== 'present';
          cb.disabled = album.status === 'present';
          cb.dataset.album = album.normalizedName;

          const nameSpan = document.createElement('span');
          nameSpan.className = 'album-name';
          nameSpan.textContent = album.name;

          const meta = document.createElement('span');
          meta.className = 'album-meta';
          if (album.status === 'incomplete') {
            meta.textContent = `${album.targetCount}/${album.files.length} tracks`;
          } else {
            meta.textContent = `${album.files.length} track${album.files.length !== 1 ? 's' : ''}`;
          }

          const badge = document.createElement('span');
          const badgeLabels = {
            missing: 'Missing',
            incomplete: 'Incomplete',
            present: 'Present',
          };
          badge.className = `badge ${album.status}`;
          badge.textContent = badgeLabels[album.status];

          li.append(cb, nameSpan, meta, badge);
          albumListEl.appendChild(li);
        }
        updateSyncButton();
      }

      function getCheckedAlbums() {
        const checked = new Set();
        for (const cb of albumListEl.querySelectorAll(
          'input[type=checkbox]:checked',
        )) {
          checked.add(cb.dataset.album);
        }
        return comparisonResults.filter((a) => checked.has(a.normalizedName));
      }

      function updateSyncButton() {
        btnSync.disabled = getCheckedAlbums().length === 0;
      }

      albumListEl.addEventListener('change', updateSyncButton);

      btnSelectAll.addEventListener('click', () => {
        for (const cb of albumListEl.querySelectorAll(
          'input[type=checkbox]:not(:disabled)',
        )) {
          cb.checked = true;
        }
        updateSyncButton();
      });

      btnSelectNone.addEventListener('click', () => {
        for (const cb of albumListEl.querySelectorAll('input[type=checkbox]')) {
          cb.checked = false;
        }
        updateSyncButton();
      });

      async function setSource(handle) {
        sourceHandle = handle;
        sourceName.textContent = handle.name;
        sourceAlbums = await scanFolder(handle);
        if (targetHandle) compare();
      }

      async function setTarget(handle) {
        targetHandle = handle;
        targetName.textContent = handle.name;
        const targetAlbums = await scanFolder(handle);
        targetAlbumCounts = new Map(
          targetAlbums.map((a) => [a.normalizedName, a.files.length]),
        );
        if (sourceHandle) compare();
      }

      btnSource.addEventListener('click', async () => {
        const handle = await pickFolder('source');
        if (handle) await setSource(handle);
      });

      btnTarget.addEventListener('click', async () => {
        const handle = await pickFolder('target');
        if (handle) await setTarget(handle);
      });

      // Drag and drop support
      async function handleDrop(e, setter) {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        const item = e.dataTransfer.items[0];
        if (!item) return;
        const handle = await item.getAsFileSystemHandle();
        if (handle?.kind !== 'directory') return;
        // Request write access (browser will prompt)
        const perm = await handle.requestPermission({ mode: 'readwrite' });
        if (perm !== 'granted') return;
        await setter(handle);
      }

      for (const [el, setter] of [
        [btnSource.closest('.folder-picker'), setSource],
        [btnTarget.closest('.folder-picker'), setTarget],
      ]) {
        el.addEventListener('dragover', (e) => {
          e.preventDefault();
          el.classList.add('drag-over');
        });
        el.addEventListener('dragleave', () =>
          el.classList.remove('drag-over'),
        );
        el.addEventListener('drop', (e) => handleDrop(e, setter));
      }

      // Sync logic
      let coreURLBlob = null;
      let wasmURLBlob = null;

      async function prepareBlobURLs() {
        if (!coreURLBlob) {
          // Document.baseURI is used because we are likely hosted in a subpath
          // of a domain, and the ffmpeg files are in /ffmpeg not
          // /assets/ffmpeg.
          const base = new URL('.', document.baseURI).href;
          coreURLBlob = await toBlobURL(
            `${base}ffmpeg/ffmpeg-core.js`,
            'text/javascript',
          );
          wasmURLBlob = await toBlobURL(
            `${base}ffmpeg/ffmpeg-core.wasm`,
            'application/wasm',
          );
        }
      }

      function appendLog(text) {
        syncLogContent.textContent += text + '\n';
        syncLogContent.scrollTop = syncLogContent.scrollHeight;
      }

      async function createFFmpeg() {
        const ff = new FFmpeg();
        ff.on('log', ({ message }) => appendLog(message));
        await ff.load({ coreURL: coreURLBlob, wasmURL: wasmURLBlob });
        return ff;
      }

      function showProgress(text, fraction) {
        progressArea.style.display = 'block';
        progressText.textContent = text;
        progressBar.style.width = `${Math.round(fraction * 100)}%`;
      }

      function hideProgress() {
        progressArea.style.display = 'none';
        progressBar.style.width = '0%';
      }

      btnSync.addEventListener('click', async () => {
        const albums = getCheckedAlbums();
        if (albums.length === 0) return;

        btnSync.disabled = true;
        btnSource.disabled = true;
        btnTarget.disabled = true;

        // Reset log and errors
        syncLogContent.textContent = '';
        syncLog.style.display = 'block';
        syncLog.open = false;
        errorNotice.style.display = 'none';
        const errors = [];

        // Count total files for progress
        const totalFiles = albums.reduce((sum, a) => sum + a.files.length, 0);
        let processedFiles = 0;
        const hasFlac = albums.some((a) =>
          a.files.some((f) => ext(f.name) === '.flac'),
        );

        if (hasFlac) {
          showProgress('Loading ffmpeg...', 0);
          await prepareBlobURLs();
        }

        for (const album of albums) {
          const albumDir = await targetHandle.getDirectoryHandle(album.name, {
            create: true,
          });
          const albumHasFlac = album.files.some((f) => ext(f.name) === '.flac');

          // Create a fresh ffmpeg instance per album to avoid memory buildup
          let ffmpeg = null;
          if (albumHasFlac) {
            showProgress(
              `${album.name} — loading transcoder...`,
              processedFiles / totalFiles,
            );
            ffmpeg = await createFFmpeg();
          }

          for (const fileHandle of album.files) {
            const file = await fileHandle.getFile();
            const fileExt = ext(file.name);
            showProgress(
              `${album.name} — ${file.name}`,
              processedFiles / totalFiles,
            );

            if (fileExt === '.flac') {
              // Transcode FLAC → ALAC
              const destName = file.name.replace(/\.flac$/i, '.m4a');
              appendLog(`\n--- Transcoding: ${album.name}/${file.name} ---`);

              await ffmpeg.writeFile(
                'input.flac',
                new Uint8Array(await file.arrayBuffer()),
              );
              const ret = await ffmpeg.exec([
                '-i',
                'input.flac',
                '-map',
                '0:a',
                '-acodec',
                'alac',
                'output.m4a',
              ]);

              if (ret !== 0) {
                errors.push(`${album.name}/${file.name}`);
                appendLog(`ERROR: ffmpeg exited with code ${ret}`);
                errorNotice.textContent = `${errors.length} file${errors.length > 1 ? 's' : ''} failed to transcode. Check the sync log for details.`;
                errorNotice.style.display = 'block';
                // Clean up and skip
                await ffmpeg.deleteFile('input.flac');
                try {
                  await ffmpeg.deleteFile('output.m4a');
                } catch {}
              } else {
                const output = await ffmpeg.readFile('output.m4a');
                appendLog(`OK: ${output.byteLength} bytes`);

                const outHandle = await albumDir.getFileHandle(destName, {
                  create: true,
                });
                const writable = await outHandle.createWritable();
                await writable.write(output);
                await writable.close();

                await ffmpeg.deleteFile('input.flac');
                await ffmpeg.deleteFile('output.m4a');
              }
            } else {
              // Copy as-is
              const outHandle = await albumDir.getFileHandle(file.name, {
                create: true,
              });
              const writable = await outHandle.createWritable();
              await writable.write(await file.arrayBuffer());
              await writable.close();
            }

            processedFiles++;
            showProgress(
              `${album.name} — ${file.name}`,
              processedFiles / totalFiles,
            );
          }

          // Terminate ffmpeg to free wasm memory
          if (ffmpeg) ffmpeg.terminate();

          // Update badge to synced
          targetAlbumCounts.set(album.normalizedName, album.files.length);
          const li = albumListEl
            .querySelector(
              `input[data-album="${CSS.escape(album.normalizedName)}"]`,
            )
            ?.closest('li');
          if (li) {
            const badge = li.querySelector('.badge');
            badge.className = 'badge synced';
            badge.textContent = 'Synced';
            const cb = li.querySelector('input');
            cb.checked = false;
            cb.disabled = true;
            li.classList.add('present');
          }
        }

        if (errors.length > 0) {
          showProgress(
            `Done with ${errors.length} error${errors.length > 1 ? 's' : ''}`,
            1,
          );
          syncLog.open = true;
        } else {
          showProgress('Done!', 1);
          setTimeout(hideProgress, 3000);
        }

        btnSource.disabled = false;
        btnTarget.disabled = false;
        updateSyncButton();
      });
    </script>
  </body>
</html>
